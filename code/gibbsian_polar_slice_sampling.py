"""
Provides an implementation of Gibbsian polar slice sampling (GPSS) that is well-
suited for use in parallelized schemes thanks to the explicit passing of RNGs.
Specifically, this module provides the following functions:

gpss: runs a single chain of GPSS for a given number of iterations

parallel_gpss: runs a number of independent chains of GPSS in parallel for a
      given number of iterations
"""

import numpy as np
import numpy.linalg as alg
import multiprocessing as mp
import time as tm
import standard_sampling_functions_gen as ssf
from parallel_plain_sampling import parallel_plain
from sampling_utils import nrange

def geo_shr(log_den_trf, r_old, theta_old, log_t, gen):
    """Auxiliary function, not to be called by the user"""
    v = ssf.uniform_great_subsphere(theta_old, gen)
    ome = gen.uniform(0,2*np.pi)
    ome_min = ome - 2*np.pi
    ome_max = ome
    theta = theta_old * np.cos(ome) + v * np.sin(ome)
    tde_cnt = 1
    while log_den_trf(r_old, theta) <= log_t:
        ome = gen.uniform(ome_min, ome_max)
        theta = theta_old * np.cos(ome) + v * np.sin(ome)
        theta = theta / alg.norm(theta) # prevents accumulating errors
        if ome < 0:
            ome_min = ome
        else:
            ome_max = ome
        tde_cnt += 1
    return theta, tde_cnt

def rad_shr(log_den_trf, r_old, log_t, theta, w, gen):
    """Auxiliary function, not to be called by the user"""
    # determine initial interval via stepping out from r_old
    ali = gen.uniform()
    r_min, r_max = ( r_old - ali * w, r_old + (1-ali) * w )
    r_min = np.max([r_min, 0])
    tde_cnt = 3 # minimal value (2 for stepping out, 1 for shrinkage)
    while r_min > 0 and log_den_trf(r_min, theta) > log_t:
        r_min = np.max([r_min - w, 0])
        tde_cnt += 1
    while log_den_trf(r_max, theta) > log_t:
        r_max += w
        tde_cnt += 1
    # sample new radius via shrinkage around r_old
    r = gen.uniform(r_min, r_max)
    ldv = log_den_trf(r, theta)
    while ldv <= log_t:
        if r < r_old:
            r_min = r
        else:
            r_max = r
        r = gen.uniform(r_min, r_max)
        ldv = log_den_trf(r, theta)
        tde_cnt += 1
    return r, ldv, tde_cnt

def gpss(log_density, n_its, x_0, w, gen, bar=False):
    """Runs Gibbsian polar slice sampling, using shrinkage geodesic slice
        sampling for the direction update and stepping-out and shrinkage
        for the radius update, for a given number of iterations

        Args:
            log_density: log of the target density, must be a function taking
                a size d np array as input and returning a float representing
                the value of the log density at the given point
            n_its: number of iterations to run the algorithm for, must be non-
                negative integer
            x_0: initial state, must be size d np array describing a point 
                from the support of the target density other than the origin
            w: initial width of the radius search area, must be positive float
            gen: instance of rnd.Generator to be used for pseudo-random number
                generation during sampling
            bar: bool denoting whether or not a progress bar should be displayed
                during the sampling procedure

        Returns:
            samples: np array of shape (n_its+1, d), where samples[i] is the 
                i-th sample generated by GPSS
            gen: the generator given to the sampler in its latest state after
                the sampling performed in this call
            tde_cnts: 1d np array of size n_its+1, where tde_cnts[i] is the
                number of target density evaluations used in the i-th iteration
            runtimes: 1d np array of size n_its+1, where runtimes[i] is the
                time the chain took to perform its i-th iteration (in seconds)
    """
    d = x_0.shape[0]
    log_den_trf = lambda ra, di: (d-1)*np.log(ra) + log_density(ra*di)
    R = np.zeros(n_its+1)
    Theta = np.zeros((n_its+1, d))
    R[0] = alg.norm(x_0)
    Theta[0] = x_0 / R[0]
    ldv = np.zeros(n_its+1) # evals of log_den_trf != log_density!
    ldv[0] = log_den_trf(R[0], Theta[0])
    tde_cnts = np.zeros(n_its+1, dtype=int)
    tde_cnts[0] = 1
    runtimes = np.zeros(n_its+1)
    time_b = tm.time() # time *b*efore the iteration
    for n in nrange(n_its, bar):
        log_t = ldv[n-1] + np.log(gen.uniform())
        Theta[n], tde_cnts[n] \
            = geo_shr(log_den_trf, R[n-1], Theta[n-1], log_t, gen)
        R[n], ldv[n], tmp_cnt \
            = rad_shr(log_den_trf, R[n-1], log_t, Theta[n], w, gen)
        tde_cnts[n] += tmp_cnt
        time_a = tm.time() # time *a*fter the iteration
        runtimes[n] = time_a - time_b
        time_b = time_a
    return R.reshape(-1,1) * Theta, gen, tde_cnts, runtimes

def parallel_gpss(
        log_density,
        n_chains,
        n_its,
        x_0s,
        w,
        verbose=True,
        bar=True
    ):
    """An implementation of Gibbsian polar slice sampling that advances a number
        of chains in parallel (using CPU parallelization).

        Args:
            log_density: log of the target density, must be a function taking
                a size d np array as input and returning a float representing
                the value of the log density at the given point; must be pickle-
                able (i.e. it mustn't be a lambda function)
            n_chains: number of parallel chains to use, must be positive integer
            n_its: number of iterations to perform per chain, must be positive 
                integer
            x_0s: initial states for the parallel chains, must be 2d np array of 
                shape (n_chains,d)
            w: initial width of the radius search area, must be positive float
            verbose: bool denoting whether or not to print various status
                updates during the sampling procedure
            bar: bool denoting whether or not a progress bar should be displayed
                during the sampling procedure (for practical reasons, the 
                progress bar will display the progression of an arbitrary chain,
                not that of the slowest one)

        Returns:
            samples: np array of shape (n_its+1,n_chains,d), where 
                samples[i,j] is the i-th sample generated by the j-th chain
            tde_cnts: 2d np array of shape (n_its+1,n_chains), where
                tde_cnts[i,j] is the number of target density evaluations used
                by the j-th chain in the i-th iteration
            runtimes: 2d np array of shape (n_its+1,n_chains), where
                runtimes[i,j] is the time the j-th chain took to perform its
                i-th iteration (in seconds)
    """
    if type(w) not in [int, float, np.float64] or w <= 0:
        raise TypeError("Hyperparameter w must be a positive float!")
    return parallel_plain(
        gpss,
        log_density,
        n_chains,
        n_its,
        x_0s,
        w,
        verbose,
        bar
    )

