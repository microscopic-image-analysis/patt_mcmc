"""
Provides an implementation of hit-and-run uniform slice sampling (HRUSS) that is
well-suited for use in parallelized schemes thanks to the explicit passing of 
RNGs. Specifically, this module provides the following functions:

hruss: runs a single chain of HRUSS for a given number of iterations

parallel_hruss: runs a number of independent chains of HRUSS in parallel for a
    given number of iterations
"""

import numpy as np
import standard_sampling_functions_gen as ssf
from sampling_utils import nrange
from parallel_plain_sampling import parallel_plain

def hruss(log_density, n_its, x_0, w, gen, bar=False):
    """Runs hit-and-run uniform slice sampling for a given number of iterations

        Args:
            log_density: log of the target density, must be a function taking
                a size d np array as input and returning a float representing
                the value of the log density at the given point
            n_its: number of iterations to run the algorithm for, must be non-
                negative integer
            x_0: initial state, must be size d np array describing a point 
                from the support of the target density
            w: initial width of the update search area, must be positive float
            gen: instance of rnd.Generator to be used for pseudo-random number
                generation during sampling
            bar: bool denoting whether or not a progress bar should be displayed
                during the sampling procedure

        Returns:
            samples: np array of shape (n_its+1, d), where samples[i] is the 
                i-th sample generated by HRUSS
            gen: the generator given to the sampler in its latest state after
                the sampling performed in this call
            tde_cnts: 1d np array of size n_its+1, where tde_cnts[i] is the
                number of target density evaluations used in the i-th iteration
    """
    d = x_0.shape[0]
    X = np.zeros((n_its+1, d))
    X[0] = x_0
    ldv = np.zeros(n_its+1)
    ldv[0] = log_density(X[0])
    tde_cnts = np.zeros(n_its+1, dtype=int)
    tde_cnts[0] = 1
    for n in nrange(n_its, bar):
        log_t = ldv[n-1] + np.log(gen.uniform())
        ali = gen.uniform()
        a_min, a_max = ( -ali * w, (1-ali) * w )
        v = ssf.uniform_sphere(d, gen)
        tde_cnts[n] = 3 # min value (2 stepping out, 1 shrinkage)
        # stepping-out
        while log_density(X[n-1] + a_min * v) > log_t:
            a_min -= w
            tde_cnts[n] += 1
        while log_density(X[n-1] + a_max * v) > log_t:
            a_max += w
            tde_cnts[n] += 1
        # sampling and shrinking
        a = gen.uniform(a_min, a_max)
        x_prop = X[n-1] + a * v
        ldv_prop = log_density(x_prop)
        while ldv_prop <= log_t:
            if a < 0:
                a_min = a
            else:
                a_max = a
            a = gen.uniform(a_min, a_max)
            x_prop = X[n-1] + a * v
            ldv_prop = log_density(x_prop)
            tde_cnts[n] += 1
        X[n] = x_prop
        ldv[n] = ldv_prop
    return X, gen, tde_cnts, ldv

def parallel_hruss(
        log_density,
        n_chains,
        n_its,
        x_0s,
        w,
        verbose=True,
        bar=True
    ):
    """An implementation of hit-and-run uniform slice sampling that advances a number
        of chains in parallel (using CPU parallelization).

        Args:
            log_density: log of the target density, must be a function taking
                a size d np array as input and returning a float representing
                the value of the log density at the given point; must be pickle-
                able (i.e. it mustn't be a lambda function)
            n_chains: number of parallel chains to use, must be positive integer
            n_its: number of iterations to perform per chain, must be positive 
                integer
            x_0s: initial states for the parallel chains, must be 2d np array of 
                shape (n_chains,d)
            w: initial width of the radius search area, must be positive float
            verbose: bool denoting whether or not to print various status
                updates during the sampling procedure
            bar: bool denoting whether or not a progress bar should be displayed
                during the sampling procedure (for practical reasons, the 
                progress bar will display the progression of an arbitrary chain,
                not that of the slowest one)

        Returns:
            samples: np array of shape (n_chains, n_its+1, d), where 
                samples[i,j] is the j-th sample generated by the i-th chain
            tde_cnts: 2d np array of size (n_chains,n_its+1), where
                tde_cnts[i,j] is the number of target density evaluations used
                by the i-th chain in the j-th iteration
    """
    if type(w) not in [int, float, np.float64] or w <= 0:
        raise TypeError("Hyperparameter w must be a positive float!")
    return parallel_plain(
        hruss,
        log_density,
        n_chains,
        n_its,
        x_0s,
        w,
        verbose,
        bar
    )

