"""
Provides an implementation of random scan uniform slice sampling (RSUSS) that is
well-suited for use in parallelized schemes thanks to the explicit passing of 
RNGs. Specifically, this module provides the following functions:

rsuss: performs a given number of iterations of RSUSS

parallel_rsuss: runs a number of independent chains of RSUSS in parallel for a
    given number of iterations
"""

import numpy as np
import time as tm
from sampling_utils import nrange
from parallel_plain_sampling import parallel_plain

def basis_vector(d, i):
    """Auxiliary function, not to be called by the user"""
    b = np.zeros(d)
    b[i] = 1.0
    return b

def rsuss(log_density, n_its, x_0, w, gen, bar=False):
    """Runs random scan uniform slice sampling, updating the chain's state only 
        in a single coordinate per iteration, for a given number of iterations

        Args:
            log_density: log of the target density, must be a function taking
                a size d np array as input and returning a float representing
                the value of the log density at the given point
            n_its: number of iterations to run the algorithm for, must be non-
                negative integer
            x_0: initial state, must be size d np array describing a point 
                from the support of the target density
            w: initial width of the search interval, must be positive float
            gen: instance of rnd.Generator to be used for pseudo-random number
                generation during sampling
            bar: bool denoting whether or not a progress bar should be displayed
                during the sampling procedure

        Returns:
            samples: np array of shape (n_its+1, d), where samples[i] is the 
                i-th sample generated by RSUSS
            gen: the generator given to the sampler in its latest state after
                the sampling performed in this call
            tde_cnts: 1d np array of size n_its+1, where tde_cnts[i] is the
                number of target density evaluations used in the i-th iteration
            runtimes: 1d np array of size n_its+1, where runtimes[i] is the
                time the chain took to perform its i-th iteration (in seconds)
            ldv: 2d np array of shape (n_its+1,n_chains) giving the log density
                values for all samples of all chains
    """
    d = x_0.shape[0]
    X = np.zeros((n_its+1, d))
    X[0] = x_0
    ldv = np.zeros(n_its+1)
    ldv[0] = log_density(X[0])
    tde_cnts = np.zeros(n_its+1, dtype=int)
    tde_cnts[0] = 1
    runtimes = np.zeros(n_its+1)
    time_b = tm.time()
    for n in nrange(n_its, bar):
        log_t = ldv[n-1] + np.log(gen.uniform())
        ali = gen.uniform()
        alpha_min, alpha_max = ( -ali * w, (1-ali) * w )
        v = basis_vector(d, gen.integers(d))
        tde_cnts[n] = 3 # minimal value (2 stepping out, 1 shrinkage)
        # stepping-out
        while log_density(X[n-1] + alpha_min * v) > log_t:
            alpha_min -= w
            tde_cnts[n] += 1
        while log_density(X[n-1] + alpha_max * v) > log_t:
            alpha_max += w
            tde_cnts[n] += 1
        # sampling and shrinking
        alpha = gen.uniform(alpha_min, alpha_max)
        x_prop = X[n-1] + alpha * v
        ldv_prop = log_density(x_prop)
        while ldv_prop <= log_t:
            if alpha < 0:
                alpha_min = alpha
            else:
                alpha_max = alpha
            alpha = gen.uniform(alpha_min, alpha_max)
            x_prop = X[n-1] + alpha * v
            ldv_prop = log_density(x_prop)
            tde_cnts[n] += 1
        X[n] = x_prop
        ldv[n] = ldv_prop
        time_a = tm.time()
        runtimes[n] = time_a - time_b
        time_b = time_a
    return X, gen, tde_cnts, runtimes, ldv

def parallel_rsuss(
        log_density,
        n_chains,
        n_its,
        x_0s,
        w,
        verbose=True,
        bar=True
    ):
    """An implementation of random scan uniform slice sampling that advances a
        number of chains in parallel (using CPU parallelization).

        Args:
            log_density: log of the target density, must be a function taking
                a size d np array as input and returning a float representing
                the value of the log density at the given point; must be pickle-
                able (i.e. it mustn't be a lambda function)
            n_chains: number of parallel chains to use, must be positive integer
            n_its: number of iterations to perform per chain, must be positive 
                integer
            x_0s: initial states for the parallel chains, must be 2d np array of 
                shape (n_chains,d)
            w: initial width of the radius search area, must be positive float
            verbose: bool denoting whether or not to print various status
                updates during the sampling procedure
            bar: bool denoting whether or not a progress bar should be displayed
                during the sampling procedure (for practical reasons, the 
                progress bar will display the progression of an arbitrary chain,
                not that of the slowest one)

        Returns:
            samples: np array of shape (n_chains, n_its+1, d), where 
                samples[i,j] is the j-th sample generated by the i-th chain
            tde_cnts: 2d np array of shape (n_chains,n_its+1), where
                tde_cnts[i,j] is the number of target density evaluations used
                by the i-th chain in the j-th iteration
            runtimes: 2d np array of shape (n_chains,n_its+1), where
                runtimes[i,j] is the time the i-th chain took to perform its
                j-th iteration (in seconds)
    """
    if type(w) not in [int, float, np.float64] or w <= 0:
        raise TypeError("Hyperparameter w must be a positive float!")
    return parallel_plain(
        rsuss,
        log_density,
        n_chains,
        n_its,
        x_0s,
        w,
        verbose,
        bar
    )

