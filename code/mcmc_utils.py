"""
Provides some utility functions for the analysis of MCMC runs. Note that the
functions of this module do not implement validity checking for their arguments,
i.e. providing them with arguments that do not conform to the specifications
made within their docstrings is likely to cause runtime errors.

Available Functions:
    get_radii
    get_radii_list
    get_log_radii
    get_log_radii_list
    get_steps
    get_steps_list
    get_flat_steps
    get_flat_steps_list
    mean_tde_list
    mss
    mss_list
    iat
    iat_list
    iat_multi_chain
    iat_multi_chain_list
    mean_iat
    mean_iat_list
    mean_iat_multi_chain
    mean_iat_multi_chain_list
"""

import numpy as np
import numpy.linalg as alg
import multiprocessing as mp
from threadpoolctl import threadpool_limits

def get_radii(samples):
    """Computes the radii (Euclidean norms) of given samples.

        Args:
            samples: either 2d np array of shape (n_its,d) where samples[i]
                is the i-th sample, or 3d np array of shape (n_its,n_chains,d),
                where samples[i,j] is the i-th sample of the j-th chain

        Returns:
            radii: in the 2d input case, 1d np array of size n_its, where
                radii[i] is the Euclidean norm of samples[i]; in the 3d input
                case, 2d np array of shape (n_its, n_chains), where
                radii[i,j] is the Euclidean norm of samples[i,j]
    """
    return alg.norm(samples, axis=-1)

def get_radii_list(sam_list):
    """Computes the radii (Euclidean norms) of given samples. See get_radii for
        details on the routine applied to each list entry.

        Args:
            sam_list: list of 2d or 3d np arrays containing samples generated by
                a single-chain or multi-chain sampler

        Returns:
            radii_list: list of 1d or 2d np arrays containing the radii of the
                given samples
    """
    return [get_radii(samples) for samples in sam_list]

def get_log_radii(samples):
    """Computes the logs (natural logarithms) of radii (Euclidean norms) of
        given samples.

        Args:
            samples: either 2d np array of shape (n_its,d) where samples[i]
                is the i-th sample, or 3d np array of shape (n_its,n_chains,d),
                where samples[i,j] is the i-th sample of the j-th chain

        Returns:
            log_radii: in the 2d input case, 1d np array of size n_its,
                where log_radii[i] is the natural logarithm of the Euclidean
                norm of samples[i]; in the 3d input case, 2d np array of shape
                (n_its, n_chains), where log_radii[i,j] is the natural
                logarithm of the Euclidean norm of samples[i,j]
    """
    return np.log(get_radii(samples))

def get_log_radii_list(sam_list):
    """Computes the logarithms of radii (Euclidean norms) of given samples. See
        get_log_radii for details on the routine applied to each list entry.

        Args:
            sam_list: list of 2d or 3d np arrays containing samples generated by
                a single-chain or multi-chain sampler

        Returns:
            log_radii_list: list of 1d or 2d np arrays containing the log radii
                of the given samples
    """
    return [get_log_radii(samples) for samples in sam_list]

def get_steps(samples):
    """Computes the empirical step sizes, i.e. the Euclidean distances between
        each pair of consecutive samples, for a given sequence of samples.

        Args:
            samples: either 2d np array of shape (n_its,d) where samples[i]
                is the i-th sample, or 3d np array of shape (n_its,n_chains,d),
                where samples[i,j] is the i-th sample of the j-th chain

        Returns:
            steps: in the 2d input case, 1d np array of size n_its-1, where
            steps[i] is the Euclidean distance between samples[i] and
            samples[i+1]; in the 3d input case, 2d np array of shape
            (n_its-1, n_chains), where steps[i,j] is the Euclidean distance
            between samples[i,j] and samples[i+1,j]
    """
    return alg.norm(samples[1:] - samples[:-1], axis=-1)

def get_steps_list(sam_list):
    """Computes the empirical step sizes for given samples. See get_steps for
        details on the routine applied to each list entry.

        Args:
            sam_list: list of 2d or 3d np arrays containing samples generated by
                a single-chain or multi-chain sampler

        Returns:
            steps_list: list of 1d or 2d np arrays containing the step sizes for
                the given samples
    """
    return [get_steps(samples) for samples in sam_list]

def get_flat_steps(samples):
    """Computes the empirical step sizes, i.e. the Euclidean distances between
        each pair of consecutive samples, for a given array of sequences of
        samples generated by a multi-chain sampler. The resulting step size
        matrix is then flattened into a 1d np array of step sizes.

        Args:
            samples: 3d np array of shape (n_its,n_chains,d), where samples[i,j]
                is the i-th sample of the j-th chain

        Returns:
            flat_steps: 1d np array of size (n_its-1) * n_chains containing
                the empirical step sizes of the given samples
    """
    return alg.norm(samples[1:] - samples[:-1], axis=-1).reshape(-1)

def get_flat_steps_list(sam_list):
    """Computes the empirical step sizes for the samples of several multi-chain
        samplers given as a list. For each sampler, the step size matrix is
        flattened into a 1d np array of step sizes. See get_flat_steps for
        details on the routine applied to each list entry.

        Args:
            sam_list: list of 3d np arrays of shape (n_its,n_chains,d) contain-
                ing samples generated by several multi-chain samplers (the shape
                may vary across the list entries)

        Returns:
            steps_list: list of 1d np arrays containing the flattened step size
                matrices for the given samples
    """
    return [get_flat_steps(samples) for samples in sam_list]

def mean_tde_list(tde_list):
    """Computes the mean of each element of a list of arrays of target density
        evaluation (TDE) counts. If the arrays are multi-dimensional, the mean
        is taken over all dimensions.

        Args:
            tde_list: list of np arrays of TDE counts

        Returns:
            mean_tde: np array of mean TDE counts (same length as tde_list)
    """
    return np.array([np.mean(tde) for tde in tde_list])

def mss(samples):
    """Computes the mean step size of given samples.

        Args:
            samples: either 2d np array of shape (n_its,d) where samples[i]
                is the i-th sample, or 3d np array of shape (n_its,n_chains,d),
                where samples[i,j] is the i-th sample of the j-th chain

        Returns:
            mss: a single float giving the mean step size of the samples
    """
    return np.mean(get_steps(samples))

def mss_list(sam_list):
    """Computes the mean step size of given samples for several instances given
        as a list. See mss for details on the routine applied to each list
        entry.

        Args:
            sam_list: list of 2d or 3d np arrays containing samples generated by
                a single-chain or multi-chain sampler

        Returns:
            mss_list: 1d np array, where mss_list[i] is the MSS of the samples
                in sam_list[i]
    """
    return np.array([mss(samples) for samples in sam_list])

@threadpool_limits.wrap(limits=1) # suppress numpy's automatic parallelization
def iat(vals, maxl=None):
    """Estimates the integrated autocorrelation time of the given values based
        on their empirical autocorrelations and the heuristic stopping criterion
        proposed by Gelman et al. in the book "Bayesian Data Analysis", Chapter
        11.5, which serves to both reduce estimation noise in the results and
        speed up the computation.

        Args:
            vals: values to compute IAT for, should be 1d np array
            maxl: largest lag between iterations to consider when estimating the
                IAT; per default, maxl will be set to vals.shape[0]//2

        Returns:
            iat: a positive float giving the (estimated) IAT for vals 
    """
    n = vals.shape[0]
    if maxl == None:
        maxl = n//2
    cvals = vals - np.mean(vals)
    autocov = lambda l: np.inner(cvals[l:], cvals[:n-l]) / (n - 1)
    autocov_0 = autocov(0)
    autocor = np.zeros(maxl)
    T = maxl-1
    for l in range(maxl):
        autocor[l] = autocov(l) / autocov_0
        if l % 2 == 1 and autocor[l] + autocor[l-1] < 0:
            T = l-2
            break
    iat = 1 + 2 * np.sum(autocor[1:T+1])
    return np.max([iat, 1.0])

def iat_list(val_list, maxl=None):
    """Computes the IAT of given values for several instances given as a list.
        See iat for details on the routine applied to each list entry.

        Args:
            val_list: list of 1d np arrays containing values
            maxl: largest lag between iterations to consider when estimating the
                IAT, should be an int or a list of the same length as val_list
                containing only int/None entries; if left None, maxl will be set
                to half the length of the value array in question

        Returns:
            iat_list: 1d np array, where iat_list[i] is the IAT of the values in
                val_list[i] 
    """
    if type(maxl) in [type(None), int]:
        maxl = len(val_list) * [maxl]
    return np.array([iat(vals, ml) for vals, ml in zip(val_list, maxl)])

def iat_multi_chain(vals, maxl=None):
    """Computes the IAT of summary values of samples generated by a multi-chain
        sampler, i.e. IATs are computed separately for each univariate marginal
        of each chain and then the arithmetic mean is taken over all these IAT
        values.

        Args:
            vals: 2d np array of shape (n_its,n_chains) where vals[i,j]
                summarizes the i-th sample generated by the j-th chain
            maxl: largest lag between iterations to consider when estimating the
                IAT; per default, maxl will be set to n_its//2

        Returns:
            iat: a positive float giving the IAT for vals (computed separately
                for the different chains and then averaged over them)
    """
    n_chains = vals.shape[1]
    starmap_args = [(vals[:,i], maxl) for i in range(n_chains)]
    with mp.Pool(n_chains) as pool:
        iats = pool.starmap(iat, starmap_args)
    return np.mean(np.array(iats))

def iat_multi_chain_list(val_list, maxl=None):
    """Computes the IAT of given summary values of the samples of several multi-
        chain samplers given as a list. See iat_multi_chain for details on the
        routine applied to each list entry.

        Args:
            val_list: list of 2d np arrays of shape (n_its,n_chains) containing
                scalar summaries of samples generated by multi-chain samplers
                (the shape may vary across the list entries)
            maxl: largest lag between iterations to consider when estimating the
                IAT, should be an int or a list of the same length as val_list
                containing only int/None entries; if left None, maxl will be set
                to half the length of the value array in question

        Returns:
            iat_list: 1d np array, where iat_list[i] is the IAT of the values
                in val_list[i] (computed separately for the different chains
                and then averaged over them)
    """
    if type(maxl) in [type(None), int]:
        maxl = len(val_list) * [maxl]
    return np.array([iat_multi_chain(vals, ml) \
                     for vals, ml in zip(val_list, maxl)])

@threadpool_limits.wrap(limits=1) # suppress numpy's automatic parallelization
def mean_iat(samples, maxl=None):
    """Computes the mean marginal IAT of given samples, i.e. the arithmetic 
        mean of the IATs of the marginal samples for each univariate marginal.

        Args:
            samples: 2d np array of shape (n_its,d) where samples[i] is the
                i-th sample
            maxl: largest lag between iterations to consider when estimating the
                IAT; per default, maxl will be set to n_its//2

        Returns:
            mean_iat: a positive float giving the mean IAT for samples
    """
    return np.mean(iat_list(samples.T, maxl))

def mean_iat_list(sam_list, maxl=None):
    """Computes the mean IAT of given samples for several instances given as a
        list. See mean_iat for details on the routine applied to each list
        entry.

        Args:
            sam_list: list of 2d np arrays containing samples
            maxl: largest lag between iterations to consider when estimating the
                IAT, should be an int or a list of the same length as val_list
                containing only int/None entries; if left None, maxl will be set
                to half the length of the value array in question

        Returns:
            mean_iat_list: 1d np array, where mean_iat_list[i] is the mean IAT
                of the samples in sam_list[i] 
    """
    if type(maxl) in [type(None), int]:
        maxl = len(sam_list) * [maxl]
    return np.array([mean_iat(sams, ml) for sams, ml in zip(sam_list, maxl)])

def mean_iat_multi_chain(samples, maxl=None):
    """Computes the mean marginal IAT of samples generated by a multi-chain
        sampler, i.e. IATs are computed separately for each univariate marginal
        of each chain and then the arithmetic mean is taken over all these IAT
        values.

        Args:
            samples: 3d np array of shape (n_its,n_chains,d) where samples[i,j]
                is the i-th sample of the j-th chain
            maxl: largest lag between iterations to consider when estimating the
                IAT; per default, maxl will be set to n_its//2

        Returns:
            mean_iat: a positive float giving the mean IAT for samples
    """
    n_chains = samples.shape[1]
    starmap_args = [(samples[:,i], maxl) for i in range(n_chains)]
    with mp.Pool(n_chains) as pool:
        mean_iats = pool.starmap(mean_iat, starmap_args)
    return np.mean(np.array(mean_iats))

def mean_iat_multi_chain_list(sam_list, maxl=None):
    """Computes the mean IAT of the samples of several multi-chain samplers
        given as a list. See mean_iat_multi_chain for details on the routine
        applied to each list entry.

        Args:
            sam_list: list of 3d np arrays of shape (n_its,n_chains,d) contain-
                ing samples generated by several multi-chain samplers
            maxl: largest lag between iterations to consider when estimating the
                IAT, should be an int or a list of the same length as val_list
                containing only int/None entries; if left None, maxl will be set
                to half the length of the value array in question

        Returns:
            mean_iat_list: 1d np array, where mean_iat_list[i] is the mean IAT
                of the samples in sam_list[i] 
    """
    if type(maxl) in [type(None), int]:
        maxl = len(sam_list) * [maxl]
    return np.array([mean_iat_multi_chain(sams, ml) \
                     for sams, ml in zip(sam_list, maxl)])

